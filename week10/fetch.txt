FETCH:

The Fetch API provides a javaScript interface for accessing and manipulating parts of the HTML pipeline such as requests and responses. 

The basic fetch requests looks like this:
fetch('http://example.com/movies.json')
  .then(response => response.json())
  .then(data => console.log(data));


fetch has response and request methods.
The promise resolves to Response. It only rejects when there is a network error.
The then() handler checks the response.ok and/or response.status.

The fetch() medthod utilizes the Window or workerglobalscope and is available. 
fetch(resource)
fetch(resource, init)

resource:
Defines the resource you want to fetch. It can be either a string with a stringifier - including a URL object that provides the resource you want to fetch. 
OR
A Request object.

FETCH EXAMPLE:

const myImage = document.querySelector('img');

const myRequest = new Request('flowers.jpg');

fetch(myRequest)
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${ response.status }`);
    }

    return response.blob();
  })
  .then((response) => {
    myImage.src = URL.createObjectURL(response);
  });
--------------------------

FETCH WITH INIT: 

const myImage = document.querySelector('img');

const myHeaders = new Headers();
myHeaders.append('Accept', 'image/jpeg');

const myInit = {
  method: 'GET',
  headers: myHeaders,
  mode: 'cors',
  cache: 'default',
};

const myRequest = new Request('flowers.jpg');

fetch(myRequest, myInit)
  .then((response) => {
    // ...
  });

______________________________
The request method uses either GET or POST. 
Options for the body of the fetch include:
Blob, arrayBuffer, typedArray, dataView, FormData, URLSearchParams or ReadableStream.

Mode: cors, no-cors, or same-origin.


Return value is a promise that resolves to a response object. 

PROMISE:

The Promise ojbect represents the eventual completion or failure of an asynchronous operation.

doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })


  .catch(failureCallback);
with arrow functions () => x is short for () => { return x; }

----------------

new Promise((resolve, reject) => {
  console.log("Initial");

  resolve();
})
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });

Initial
Do that
Do this, no matter what happened before

-----------------------

async function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}

Response:

The Response interface of the Fetch API represents the response to a request.


RESPONSE constructor:

new Response()
new Response(body)
new Response(body, options)

Response.ok
The ok read-only property of the Response interface contains a Boolean stating whether the response was successful

-------------------------

 const myImage = document.querySelector("img");

    const myRequest = new Request("flowers.jpg");

    fetch(myRequest)
      .then((response) => {
        console.log(response.type);
        console.log(response.url);
        console.log(response.useFinalURL);
        console.log(response.status);
        console.log(response.ok);
        console.log(response.statusText);
        console.log(response.headers);
        if (!response.ok) {
          throw new Error(`HTTP error, status = ${response.status}`);
        }
        return response.blob();
      })
      .then((myBlob) => {
        const objectURL = URL.createObjectURL(myBlob);
        myImage.src = objectURL;
      })
      .catch((error) => {
        const p = document.createElement("p");
        p.appendChild(document.createTextNode(`Error: ${error.message}`));
        document.body.insertBefore(p, myImage);
      });

    const myBlob = new Blob();
    const options = { status: 200, statusText: "SuperSmashingGreat!" };
    const myResponse = new Response(myBlob, options);
